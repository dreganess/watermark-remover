<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Watermark Remover</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0d0d0d;
  color: #e0e0e0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ── HEADER ── */
header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 14px 28px;
  background: #111;
  border-bottom: 1px solid #222;
  flex-shrink: 0;
}
.brand { display: flex; align-items: center; gap: 10px; }
.brand svg { color: #6366f1; }
.brand h1 { font-size: 1.05rem; font-weight: 600; letter-spacing: -0.2px; }
.badge {
  font-size: 0.68rem; padding: 2px 8px; border-radius: 20px;
  background: #1e1b4b; color: #818cf8; border: 1px solid #312e81;
}
.header-actions { display: flex; gap: 10px; align-items: center; }

/* ── BUTTONS ── */
.btn {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 7px 14px; border-radius: 7px; font-size: 0.82rem;
  font-weight: 500; cursor: pointer; border: none; transition: all 0.15s;
}
.btn-ghost {
  background: transparent; color: #888; border: 1px solid #2a2a2a;
}
.btn-ghost:hover:not(:disabled) { background: #1a1a1a; color: #ccc; border-color: #444; }
.btn-primary {
  background: #6366f1; color: #fff;
}
.btn-primary:hover:not(:disabled) { background: #4f46e5; }
.btn:disabled { opacity: 0.35; cursor: not-allowed; }

/* ── UPLOAD ZONE ── */
#uploadZone {
  flex: 1; display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  gap: 24px; padding: 48px;
}
.drop-card {
  border: 2px dashed #2a2a2a; border-radius: 16px;
  padding: 56px 72px; display: flex; flex-direction: column;
  align-items: center; gap: 16px; cursor: pointer;
  transition: all 0.2s; max-width: 480px; text-align: center;
}
.drop-card:hover, .drop-card.drag { border-color: #6366f1; background: #0f0f20; }
.drop-card svg { color: #444; transition: color 0.2s; }
.drop-card:hover svg, .drop-card.drag svg { color: #6366f1; }
.drop-card p { color: #555; font-size: 0.88rem; line-height: 1.5; }
.drop-card strong { color: #999; font-size: 1rem; }
.hint-chips { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
.chip {
  font-size: 0.75rem; padding: 3px 10px; border-radius: 20px;
  background: #1a1a1a; color: #666; border: 1px solid #2a2a2a;
}
#fileInput { display: none; }

/* ── EDITOR ── */
#editor { flex: 1; display: none; flex-direction: column; }

.toolbar {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 20px; background: #111; border-bottom: 1px solid #1e1e1e;
  flex-shrink: 0; gap: 12px; flex-wrap: wrap;
}
.toolbar-hint {
  display: flex; align-items: center; gap: 8px;
  font-size: 0.82rem; color: #666;
}
.toolbar-hint .dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: #6366f1; animation: pulse 2s infinite;
}
@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(1.4); }
}
.toolbar-right { display: flex; gap: 8px; align-items: center; }

/* ── CANVAS AREA ── */
.canvas-area {
  flex: 1; overflow: auto; display: flex;
  align-items: flex-start; justify-content: center;
  padding: 24px; position: relative;
  background: repeating-conic-gradient(#161616 0% 25%, #111 0% 50%) 0 0 / 20px 20px;
}
.canvas-wrap {
  position: relative; display: inline-block; line-height: 0;
  border-radius: 8px; overflow: hidden;
  box-shadow: 0 0 0 1px #2a2a2a, 0 24px 48px rgba(0,0,0,0.6);
  max-width: 100%;
}
#mainCanvas {
  display: block; max-width: 100%;
  cursor: crosshair;
}
#mainCanvas.loading { cursor: wait; }

/* ── RIPPLE ── */
.ripple {
  position: absolute; border-radius: 50%; pointer-events: none;
  border: 2px solid #6366f1;
  animation: rippleOut 0.8s ease-out forwards;
  transform: translate(-50%, -50%);
}
@keyframes rippleOut {
  from { width: 0; height: 0; opacity: 1; }
  to   { width: 120px; height: 120px; opacity: 0; }
}
.click-dot {
  position: absolute; width: 10px; height: 10px;
  background: #6366f1; border-radius: 50%; pointer-events: none;
  transform: translate(-50%, -50%);
  animation: dotFade 0.8s ease-out forwards;
}
@keyframes dotFade {
  from { opacity: 1; transform: translate(-50%,-50%) scale(1); }
  to   { opacity: 0; transform: translate(-50%,-50%) scale(0.2); }
}

/* ── PROCESSING OVERLAY ── */
#processingOverlay {
  display: none; position: absolute; inset: 0;
  background: rgba(0,0,0,0.55); backdrop-filter: blur(2px);
  align-items: center; justify-content: center; flex-direction: column; gap: 12px;
  border-radius: 8px;
}
#processingOverlay.show { display: flex; }
.spinner-ring {
  width: 36px; height: 36px;
  border: 3px solid #2a2a2a; border-top-color: #6366f1;
  border-radius: 50%; animation: spin 0.7s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
#processingOverlay p { font-size: 0.82rem; color: #aaa; }

/* ── STATUS BAR ── */
.statusbar {
  display: flex; align-items: center; justify-content: space-between;
  padding: 6px 20px; background: #0d0d0d; border-top: 1px solid #1e1e1e;
  font-size: 0.75rem; color: #444; flex-shrink: 0;
}
.statusbar span { color: #666; }

/* ── TOAST ── */
.toast {
  position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
  background: #1e293b; color: #e2e8f0; padding: 9px 18px; border-radius: 8px;
  font-size: 0.82rem; border: 1px solid #334; z-index: 999;
  opacity: 0; pointer-events: none; transition: opacity 0.25s;
}
.toast.show { opacity: 1; }

/* ── BOTTOM BAR ── */
.bottom-bar {
  display: flex; justify-content: center; padding: 12px 16px;
  background: #111; border-top: 1px solid #1e1e1e; flex-shrink: 0;
}
.btn-download {
  padding: 14px 40px; font-size: 1rem; border-radius: 12px;
  width: 100%; max-width: 400px;
}

/* ── COMPARE TOGGLE ── */
.toggle-group { display: flex; border: 1px solid #2a2a2a; border-radius: 6px; overflow: hidden; }
.toggle-btn {
  padding: 5px 12px; font-size: 0.78rem; cursor: pointer;
  background: transparent; color: #666; border: none;
  transition: all 0.15s;
}
.toggle-btn.active { background: #1e1b4b; color: #818cf8; }
</style>
</head>
<body>

<!-- HEADER -->
<header>
  <div class="brand">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 2l2.4 7.4H22l-6.2 4.5 2.4 7.4L12 17l-6.2 4.3 2.4-7.4L2 9.4h7.6z"/>
    </svg>
    <h1>Watermark Remover</h1>
    <span class="badge">Click to Erase</span>
  </div>
  <div class="header-actions">
    <button class="btn btn-ghost" id="newImageBtn" style="display:none">
      <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
      New Image
    </button>
    <button class="btn btn-ghost" id="undoBtn" disabled>
      <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="9 14 4 9 9 4"/><path d="M20 20v-7a4 4 0 00-4-4H4"/></svg>
      Undo
    </button>
  </div>
</header>

<!-- UPLOAD ZONE -->
<div id="uploadZone">
  <label class="drop-card" for="fileInput" id="dropCard">
    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/>
      <polyline points="21 15 16 10 5 21"/>
    </svg>
    <strong>Drop image here or click to upload</strong>
    <p>Upload an image with a Gemini watermark.<br/>Then just tap the watermark to erase it.</p>
    <div class="hint-chips">
      <span class="chip">PNG</span>
      <span class="chip">JPEG</span>
      <span class="chip">WEBP</span>
    </div>
  </label>
  <input type="file" id="fileInput" accept="image/*"/>
</div>

<!-- EDITOR -->
<div id="editor">
  <div class="toolbar">
    <div class="toolbar-hint">
      <div class="dot"></div>
      <span id="hintText">Tap the watermark to erase it</span>
    </div>
    <div class="toolbar-right">
      <div class="toggle-group" id="viewToggle" style="display:none">
        <button class="toggle-btn active" data-view="current">Current</button>
        <button class="toggle-btn" data-view="original">Original</button>
      </div>
    </div>
  </div>

  <div class="canvas-area">
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="mainCanvas"></canvas>
      <div id="processingOverlay">
        <div class="spinner-ring"></div>
        <p>Detecting &amp; removing watermark…</p>
      </div>
    </div>
  </div>

  <!-- Download button below the image -->
  <div class="bottom-bar">
    <button class="btn btn-primary btn-download" id="downloadBtn" disabled>
      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
      Save Image
    </button>
  </div>

  <div class="statusbar">
    <span id="statusDim">—</span>
    <span id="statusCount"></span>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
// ── State ──────────────────────────────────────────────────────────────────────
let history    = [];   // stack of data URLs (index 0 = original)
let current    = 0;    // index into history we're currently showing
let isLoading  = false;
let viewMode   = 'current';

// ── Elements ───────────────────────────────────────────────────────────────────
const uploadZone  = document.getElementById('uploadZone');
const editorEl    = document.getElementById('editor');
const fileInput   = document.getElementById('fileInput');
const dropCard    = document.getElementById('dropCard');
const canvas      = document.getElementById('mainCanvas');
const overlay     = document.getElementById('processingOverlay');
const canvasWrap  = document.getElementById('canvasWrap');
const newImageBtn = document.getElementById('newImageBtn');
const undoBtn     = document.getElementById('undoBtn');
const downloadBtn = document.getElementById('downloadBtn');
const statusDim   = document.getElementById('statusDim');
const statusCount = document.getElementById('statusCount');
const hintText    = document.getElementById('hintText');
const viewToggle  = document.getElementById('viewToggle');
const toast       = document.getElementById('toast');

const ctx = canvas.getContext('2d');

// ── Toast ──────────────────────────────────────────────────────────────────────
function showToast(msg, ms = 2800) {
  toast.textContent = msg;
  toast.classList.add('show');
  clearTimeout(showToast._t);
  showToast._t = setTimeout(() => toast.classList.remove('show'), ms);
}

// ── Image loading ──────────────────────────────────────────────────────────────
function loadDataUrl(dataUrl) {
  const img = new Image();
  img.onload = () => {
    canvas.width  = img.naturalWidth;
    canvas.height = img.naturalHeight;
    ctx.drawImage(img, 0, 0);

    history = [dataUrl];
    current = 0;
    viewMode = 'current';

    uploadZone.style.display = 'none';
    editorEl.style.display   = 'flex';
    newImageBtn.style.display = '';
    undoBtn.disabled    = true;
    downloadBtn.disabled = true;
    viewToggle.style.display = 'none';

    statusDim.textContent   = `${img.naturalWidth} × ${img.naturalHeight}`;
    statusCount.textContent = '';
    hintText.textContent    = 'Tap the watermark to erase it';

    document.querySelectorAll('.toggle-btn').forEach(b => b.classList.toggle('active', b.dataset.view === 'current'));
  };
  img.src = dataUrl;
}

fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => loadDataUrl(ev.target.result);
  reader.readAsDataURL(file);
  fileInput.value = '';
});

// Drag & drop
dropCard.addEventListener('dragover',  e => { e.preventDefault(); dropCard.classList.add('drag'); });
dropCard.addEventListener('dragleave', ()=> dropCard.classList.remove('drag'));
dropCard.addEventListener('drop', e => {
  e.preventDefault(); dropCard.classList.remove('drag');
  const file = e.dataTransfer.files[0];
  if (!file || !file.type.startsWith('image/')) return;
  const reader = new FileReader();
  reader.onload = ev => loadDataUrl(ev.target.result);
  reader.readAsDataURL(file);
});

newImageBtn.addEventListener('click', () => {
  uploadZone.style.display = '';
  editorEl.style.display   = 'none';
  newImageBtn.style.display = 'none';
  history = []; current = 0;
});

// ── View toggle (original / current) ──────────────────────────────────────────
viewToggle.addEventListener('click', e => {
  const btn = e.target.closest('.toggle-btn');
  if (!btn) return;
  viewMode = btn.dataset.view;
  document.querySelectorAll('.toggle-btn').forEach(b => b.classList.toggle('active', b === btn));
  renderHistory();
});

function renderHistory() {
  const src = viewMode === 'original' ? history[0] : history[current];
  const img = new Image();
  img.onload = () => ctx.drawImage(img, 0, 0);
  img.src = src;
}

// ── Undo ───────────────────────────────────────────────────────────────────────
undoBtn.addEventListener('click', () => {
  if (current <= 0) return;
  current--;
  viewMode = 'current';
  document.querySelectorAll('.toggle-btn').forEach(b => b.classList.toggle('active', b.dataset.view === 'current'));
  renderHistory();
  updateStatusCount();
  undoBtn.disabled = current <= 0;
  if (current === 0) {
    downloadBtn.disabled = true;
    viewToggle.style.display = 'none';
  }
});

function updateStatusCount() {
  const n = current;
  statusCount.textContent = n > 0 ? `${n} removal${n > 1 ? 's' : ''} applied` : '';
}

// ── Click → detect & remove ────────────────────────────────────────────────────
canvas.addEventListener('click', async e => {
  if (isLoading || history.length === 0) return;

  const rect   = canvas.getBoundingClientRect();
  const scaleX = canvas.width  / rect.width;
  const scaleY = canvas.height / rect.height;

  // Coordinates relative to the rendered canvas element (for ripple)
  const ex = e.clientX - rect.left;
  const ey = e.clientY - rect.top;

  // Ratios sent to backend (0-1)
  const rx = (ex * scaleX) / canvas.width;
  const ry = (ey * scaleY) / canvas.height;

  spawnRipple(ex, ey);
  await removeWatermark(rx, ry);
});

// Touch support
canvas.addEventListener('touchend', async e => {
  if (isLoading || history.length === 0) return;
  e.preventDefault();
  const touch  = e.changedTouches[0];
  const rect   = canvas.getBoundingClientRect();
  const ex = touch.clientX - rect.left;
  const ey = touch.clientY - rect.top;
  const scaleX = canvas.width  / rect.width;
  const scaleY = canvas.height / rect.height;
  const rx = (ex * scaleX) / canvas.width;
  const ry = (ey * scaleY) / canvas.height;
  spawnRipple(ex, ey);
  await removeWatermark(rx, ry);
}, {passive: false});

function spawnRipple(x, y) {
  // Ripple ring
  const r = document.createElement('div');
  r.className = 'ripple';
  r.style.left = x + 'px';
  r.style.top  = y + 'px';
  canvasWrap.appendChild(r);
  r.addEventListener('animationend', () => r.remove());

  // Centre dot
  const d = document.createElement('div');
  d.className = 'click-dot';
  d.style.left = x + 'px';
  d.style.top  = y + 'px';
  canvasWrap.appendChild(d);
  d.addEventListener('animationend', () => d.remove());
}

async function removeWatermark(rx, ry) {
  isLoading = true;
  canvas.classList.add('loading');
  overlay.classList.add('show');
  hintText.textContent = 'Processing…';

  try {
    const imageDataUrl = history[current];

    const res = await fetch('/api/remove', {
      method:  'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ image: imageDataUrl, x: rx, y: ry }),
    });

    if (!res.ok) throw new Error(`Server error ${res.status}`);
    const { result } = await res.json();

    // Push onto history and display
    // Trim any forward history if we're mid-stack (shouldn't happen, but safe)
    history = history.slice(0, current + 1);
    history.push(result);
    current++;

    const img = new Image();
    img.onload = () => {
      ctx.drawImage(img, 0, 0);
      viewMode = 'current';
      document.querySelectorAll('.toggle-btn').forEach(b => b.classList.toggle('active', b.dataset.view === 'current'));
      viewToggle.style.display = '';
      undoBtn.disabled    = false;
      downloadBtn.disabled = false;
      updateStatusCount();
      hintText.textContent = 'Tap another watermark, or download your image';
    };
    img.src = result;

  } catch (err) {
    showToast('Error: ' + err.message);
    hintText.textContent = 'Tap the watermark to erase it';
  } finally {
    isLoading = false;
    canvas.classList.remove('loading');
    overlay.classList.remove('show');
  }
}

// ── Download ───────────────────────────────────────────────────────────────────
function dataURLtoBlob(dataURL) {
  const [header, data] = dataURL.split(',');
  const mime   = header.match(/:(.*?);/)[1];
  const binary = atob(data);
  const arr    = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) arr[i] = binary.charCodeAt(i);
  return new Blob([arr], {type: mime});
}

downloadBtn.addEventListener('click', async () => {
  if (current === 0) return;
  // Convert locally (no async fetch) so iOS preserves the user gesture for share
  const blob = dataURLtoBlob(history[current]);
  const file = new File([blob], 'watermark-removed.png', {type: 'image/png'});

  // iOS: Share Sheet → "Save Image" → Camera Roll
  if (navigator.canShare && navigator.canShare({files: [file]})) {
    try {
      await navigator.share({files: [file], title: 'Watermark Removed'});
    } catch (e) {
      if (e.name !== 'AbortError') showToast('Could not open share sheet');
    }
  } else {
    // Desktop: normal file download
    const url = URL.createObjectURL(blob);
    const a   = document.createElement('a');
    a.href = url; a.download = 'watermark-removed.png';
    document.body.appendChild(a);
    a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
});
</script>
</body>
</html>
